// Code generated by github.com/tvastar/test/cmd/testmd/testmd.go. DO NOT EDIT.

package dot_test

import (
	"fmt"

	"github.com/dotchain/dot/changes"
	"github.com/dotchain/dot/changes/types"
	"github.com/dotchain/dot/streams"
)

func Example_applying_changes() {
	// import fmt
	// import github.com/dotchain/dot/changes
	// import github.com/dotchain/dot/changes/types

	// S8 is DOT-compatible string type with UTF8 string indices
	initial := types.S8("hello")

	append := changes.Splice{
		Offset: len("hello"),       // end of "hello"
		Before: types.S8(""),       // nothing to remove
		After:  types.S8(" world"), // insert " world"
	}

	// apply the change
	updated := initial.Apply(nil, append)

	fmt.Println(updated)
	// Output: hello world

}

func Example_apply_stream() {
	// import fmt
	// import github.com/dotchain/dot/streams

	initial := &streams.S8{Stream: streams.New(), Value: "hello"}
	updated := initial.Splice(5, 0, " world")

	fmt.Println(updated.Value)
	// Output: hello world

}

func Example_changeset_composition() {
	// import fmt
	// import github.com/dotchain/dot/changes
	// import github.com/dotchain/dot/changes/types

	initial := types.S8("hello")

	// append " world" => "hello world"
	append1 := changes.Splice{
		Offset: len("hello"),
		Before: types.S8(""),
		After:  types.S8(" world"),
	}

	// append "." => "hello world."
	append2 := changes.Splice{
		Offset: len("hello world"),
		Before: types.S8(""),
		After:  types.S8("."),
	}

	// now combine the two appends and apply
	both := changes.ChangeSet{append1, append2}
	updated := initial.Apply(nil, both)
	fmt.Println(updated)

	// Output: hello world.

}

func Example_path_composition() {
	// import fmt
	// import github.com/dotchain/dot/changes
	// import github.com/dotchain/dot/changes/types

	// types.A is a generic array type and types.M is a map type
	initial := types.A{types.M{"hello": types.S8("world")}}

	// replace "world" with "world!"
	replace := changes.Replace{Before: types.S8("world"), After: types.S8("world!")}

	// replace "world" with "world!" of initial[0]["hello"]
	path := []interface{}{0, "hello"}
	c := changes.PathChange{Path: path, Change: replace}
	updated := initial.Apply(nil, c)
	fmt.Println(updated)

	// Output: [map[hello:world!]]

}

func Example_convergence() {
	// import fmt
	// import github.com/dotchain/dot/changes
	// import github.com/dotchain/dot/changes/types

	initial := types.S8("hello")

	// two changes: append " world" and delete "lo"
	insert := changes.Splice{Offset: 5, Before: types.S8(""), After: types.S8(" world")}
	remove := changes.Splice{Offset: 3, Before: types.S8("lo"), After: types.S8("")}

	// two versions derived from initial
	inserted := initial.Apply(nil, insert)
	removed := initial.Apply(nil, remove)

	// merge the changes
	removex, insertx := insert.Merge(remove)

	// converge by applying the above
	final1 := inserted.Apply(nil, removex)
	final2 := removed.Apply(nil, insertx)

	fmt.Println(final1, final1 == final2)
	// Output: hel world true

}

func Example_convergence_streams() {
	// import fmt
	// import github.com/dotchain/dot/streams

	initial := streams.S8{Stream: streams.New(), Value: "hello"}

	// two changes: append " world" and delete "lo"
	s1 := initial.Splice(5, 0, " world")
	s2 := initial.Splice(3, len("lo"), "")

	// streams automatically merge because they are both
	// based on initial
	s1 = s1.Latest()
	s2 = s2.Latest()

	fmt.Println(s1.Value, s1.Value == s2.Value)
	// Output: hel world true

}

func Example_branching() {
	// import fmt
	// import github.com/dotchain/dot/streams
	// import github.com/dotchain/dot/changes
	// import github.com/dotchain/dot/changes/types

	// here a generic change stream is created
	master := streams.New()
	local := streams.Branch(master)

	// changes will not be reflected on master yet
	c := changes.Replace{Before: changes.Nil, After: types.S8("hello")}
	local = local.Append(c)

	if x, c1 := master.Next(); x != nil || c1 != nil {
		fmt.Println("Master unexepectedly changed")
	}

	// push local changes up to master now
	streams.Push(local)
	if x, c2 := master.Next(); x == nil || c2 != c {
		fmt.Println("Master changed but unexpectedly", x, c2)
	}

	// Output:

}
