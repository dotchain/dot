// This file is generated by:
//    github.com/dotchain/dot/ux/templates/cache.template
//
// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

package todo

import "github.com/dotchain/dot/ux"

// TaskEditCache holds a cache of TaskEdit controls.
//
// Controls that have manage a bunch of TaskEdit controls
// should maintain a cache created like so:
//
//     cache := &TaskEditCache{}
//
// When updating, they should use the cache to reuse items:
//
//     cache.Reset()
//     defer cache.Cleanup()
//
//     ... for each TaskEdit control needed do:
//     cache.Get(key, styles, task)
//
// This allows the cache to reuse the control if the key exists.
// Otherwise a new control is created via NewTaskEdit(styles, task)
//
// When a control is reused, it is also automatically updated.
type TaskEditCache struct {
	old, current map[interface{}]*TaskEdit
}

// Reset should be called before the start of a round
func (c *TaskEditCache) Reset() {
	c.old = c.current
	c.current = map[interface{}]*TaskEdit{}
}

// Cleanup should be called at the end of a round
func (c *TaskEditCache) Cleanup() {
	// if TodoTask had a Close() method all the old left-over items
	// can be cleaned up via that call
	c.old = nil
}

// Get fetches a TaskEdit from the cache (updating it)
// or creates a new TaskEdit
//
// It returns the TaskEdit but also whether the control existed.
// This can be used to conditionally setup listeners.
func (c *TaskEditCache) Get(key interface{}, styles ux.Styles, task Task) (*TaskEdit, bool) {
	exists := false
	if item, ok := c.old[key]; !ok {
		c.current[key] = NewTaskEdit(styles, task)
	} else {
		delete(c.old, key)
		item.Update(styles, task)
		c.current[key] = item
		exists = true
	}

	return c.current[key], exists
}
