// This file is generated by:
//    github.com/dotchain/dot/ux/templates/cache.template
//
// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

package {{.Package}}

import "github.com/dotchain/dot/ux/core"

// {{.Base}}Cache holds a cache of {{.BaseType}} controls.
//
// Controls that have manage a bunch of {{.BaseType}} controls
// should maintain a cache created like so:
//
//     cache := &{{.Base}}Cache{}
//
// When updating, the cache can be used to reuse controls:
//
//     cache.Begin()
//     defer cache.End()
//
//     ... for each {{.BaseType}} control needed do:
//     cache.Get(key, {{.Args}})
//
// This allows the cache to reuse the control if the key exists.
// Otherwise a new control is created via {{.Constructor}}({{.Args}})
//
// When a control is reused, it is also automatically updated.
type {{.Base}}Cache struct {
	old, current map[interface{}]*{{.BaseType}}
}

// Begin should be called before the start of a round
func (c *{{.Base}}Cache) Begin() {
	c.old = c.current
	c.current = map[interface{}]*{{.BaseType}}{}
}

// End should be called at the end of a round
func (c *{{.Base}}Cache) End() {
	// if components had a Close() method all the old left-over items
	// can be cleaned up via that call
	c.old = nil
}

// Item fetches the item at the specific key
func (c *{{.Base}}Cache) Item(key interface{}) *{{.BaseType}} {
       return c.current[key]
}

// {{.Base}} fetches a {{.BaseType}} from the cache (updating it)
// or creates a new {{.BaseType}}
func (c *{{.Base}}Cache) {{.Base}}(key interface{}, {{.ArgsDef}}) *{{.BaseType}} {
       if item, ok := c.old[key]; !ok {
               c.current[key] = {{.Constructor}}({{.Args}})
       } else {
               delete(c.old, key)
               item.Update({{.Args}})
               c.current[key] = item
       }

       return c.current[key]
}
