// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
//
// This code is generated by github.com/dotchain/dot/ux/fn/codegen.go

package fn

import (
	"github.com/dotchain/dot/ux/core"
	"github.com/dotchain/dot/ux/simple"
)

type elementCtx struct {
	rootElementCache
	memoInitialized bool
	memoizedParams  struct {
		props    core.Props
		children []core.Element
		result1  core.Element
	}
}

func (c *elementCtx) areArgsSame(props core.Props, children ...core.Element) bool {
	if props != c.memoizedParams.props {
		return false
	}
	if len(children) != len(c.memoizedParams.children) {
		return false
	}
	for childrenIndex, childrenItem := range children {
		if childrenItem != c.memoizedParams.children[childrenIndex] {
			return false
		}
	}
	return true
}

func (c *elementCtx) refreshIfNeeded(props core.Props, children ...core.Element) (result1 core.Element) {
	if !c.memoInitialized || !c.areArgsSame(props, children...) {
		return c.refresh(props, children...)
	}
	return c.memoizedParams.result1
}

func (c *elementCtx) refresh(props core.Props, children ...core.Element) (result1 core.Element) {
	c.memoInitialized = true
	c.memoizedParams.props, c.memoizedParams.children = props, children
	c.rootElementCache.Begin()
	defer c.rootElementCache.End()
	c.memoizedParams.result1 = Element(c, props, children...)
	return c.memoizedParams.result1
}

// ElementCache is generated from Element.  Please see that for
// documentation
type ElementCache struct {
	old, current map[interface{}]*elementCtx
}

// Begin starts the round
func (c *ElementCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*elementCtx{}
}

// End ends the round
func (c *ElementCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// Element implements the cache create or fetch method
func (c *ElementCache) Element(key interface{}, props core.Props, children ...core.Element) core.Element {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &elementCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded(props, children...)
}

type rootElementCtx struct {
	memoInitialized bool
	memoizedParams  struct {
		result1 *simple.Element
	}
}

func (c *rootElementCtx) areArgsSame() bool {
	return true
}

func (c *rootElementCtx) refreshIfNeeded() (result1 *simple.Element) {
	if !c.memoInitialized || !c.areArgsSame() {
		return c.refresh()
	}
	return c.memoizedParams.result1
}

func (c *rootElementCtx) refresh() (result1 *simple.Element) {
	c.memoInitialized = true
	c.memoizedParams.result1 = rootElement(c)
	return c.memoizedParams.result1
}

// rootElementCache is generated from rootElement.  Please see that for
// documentation
type rootElementCache struct {
	old, current map[interface{}]*rootElementCtx
}

// Begin starts the round
func (c *rootElementCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*rootElementCtx{}
}

// End ends the round
func (c *rootElementCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// rootElement implements the cache create or fetch method
func (c *rootElementCache) rootElement(key interface{}) *simple.Element {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &rootElementCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded()
}
