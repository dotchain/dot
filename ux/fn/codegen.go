// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"golang.org/x/tools/imports"
	"io/ioutil"
	"os"
	"path"
	"sort"
	"strings"
	"text/template"
)

const ellipsis = "..."

func main() {
	args := os.Args[1:]
	for _, arg := range args {
		if arg != "-" {
			processFile(arg)
		}
	}
}

func processFile(fname string) {
	fbytes, err := ioutil.ReadFile(fname)
	if err != nil {
		panic(err)
	}

	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, fname, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	generated := formatImports(f)
	for _, decl := range f.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok && shouldProcess(fn) {
			generated += formatFunc(fn, fbytes)
		}
	}

	p, err := format.Source([]byte(generated))
	if err != nil {
		fmt.Println(generated)
		panic(err)
	}

	ext := path.Ext(fname)
	outf := path.Join(path.Dir(fname), fname[:len(fname)-len(ext)]+"_generated.go")
	p, err = imports.Process(outf, p, nil)
	if err != nil {
		panic(err)
	}

	if err = ioutil.WriteFile(outf, p, os.ModePerm); err != nil {
		panic(err)
	}
}

func formatImports(f *ast.File) string {
	imports := [][]string{}
	for _, spec := range f.Imports {
		im := []string{"", ""}
		if spec.Name != nil && spec.Name.Name != "_" {
			im[0] = spec.Name.Name
		}
		im[1] = spec.Path.Value
		imports = append(imports, im)
	}

	data := map[string]interface{}{"package": f.Name.Name, "imports": imports}
	t, err := template.New("header").Parse(header)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	if err = t.Execute(&buf, data); err != nil {
		panic(err)
	}
	return buf.String()
}

const header = `
// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
//
// This code is generated by github.com/dotchain/dot/ux/fn/codegen.go

package {{.package}}

import (
	"github.com/dotchain/dot/ux/streams"
{{- range $m := .imports}}
	{{index $m 0}} {{index $m 1}}
{{- end}}
)

`

func shouldProcess(fn *ast.FuncDecl) bool {
	if fn.Doc == nil || fn.Recv != nil {
		return false
	}
	for _, comment := range fn.Doc.List {
		if strings.Contains(comment.Text, "codegen:") {
			return true
		}
	}
	return false
}

func formatFunc(fn *ast.FuncDecl, fbytes []byte) string {
	inParams := [][2]string{}
	outParams := [][2]string{}

	if fn.Type.Params.List != nil {
		for _, field := range fn.Type.Params.List {
			param := [2]string{"", ""}
			if field.Names != nil {
				param[0] = field.Names[0].Name
			}
			s, e := field.Type.Pos(), field.Type.End()
			param[1] = string(fbytes[s-1 : e-1])
		}
	}

	if fn.Type.Params.List != nil {
		for _, field := range fn.Type.Params.List {
			param := [2]string{"", ""}
			if field.Names != nil {
				param[0] = field.Names[0].Name
			}
			s, e := field.Type.Pos(), field.Type.End()
			param[1] = string(fbytes[s-1 : e-1])
			inParams = append(inParams, param)
		}
	}

	if fn.Type.Results.List != nil {
		for kk, field := range fn.Type.Results.List {
			param := [2]string{fmt.Sprintf("result%d", kk+1), ""}
			if field.Names != nil {
				param[0] = field.Names[0].Name
			}
			s, e := field.Type.Pos(), field.Type.End()
			param[1] = string(fbytes[s-1 : e-1])
			outParams = append(outParams, param)
		}
	}

	usesOn := false
	subComps := []pkgComps{}
	if len(inParams) > 0 {
		context := inParams[0][0]

		visitor := &subVisitor{context, map[[2]string]bool{}, false}
		ast.Walk(visitor, fn.Body)
		packages := []string{}
		pmap := map[string][]string{}
		for pair := range visitor.subs {
			pmap[pair[0]] = append(pmap[pair[0]], pair[1])
			if len(pmap[pair[0]]) == 1 {
				packages = append(packages, pair[0])
			}
		}
		sort.Strings(packages)
		for _, pkg := range packages {
			sort.Strings(pmap[pkg])
			subComps = append(subComps, pkgComps{pkg, pmap[pkg]})
		}
		usesOn = visitor.usesOn
	}

	ctxtStruct := formatContext(fn.Name.Name, inParams, outParams, subComps, usesOn)
	cacheStruct := formatCache(fn.Name.Name, inParams, outParams, subComps)
	return ctxtStruct + cacheStruct
}

type pkgComps struct {
	pkg   string
	comps []string
}

func formatContext(name string, inParams [][2]string, outParams [][2]string, subComps []pkgComps, usesOn bool) string {
	if inParams[0][1][:1] != "*" {
		panic("first arg of " + name + " is not a pointer context type")
	}

	result := fmt.Sprintf("type %s struct {\n", inParams[0][1][1:])
	if usesOn {
		result += "  streams.Subs\n"
	}

	for _, pkgComps := range subComps {
		if pkgComps.pkg != "" {
			result += fmt.Sprintf("  %s struct {\n", pkgComps.pkg)
		}
		for _, comp := range pkgComps.comps {
			if pkgComps.pkg != "" {
				result += pkgComps.pkg + "." + comp + "Cache\n"
			} else {
				result += comp + "Cache\n"
			}
		}
		if pkgComps.pkg != "" {
			result += "}\n\n"
		}
	}

	if len(inParams) > 1 || len(outParams) > 0 {
		result += "memoInitialized bool\nmemoizedParams struct {\n "
		for _, pair := range inParams[1:] {
			typeName := pair[1]
			if strings.HasPrefix(typeName, ellipsis) {
				typeName = "[]" + typeName[3:]
			}
			result += pair[0] + " " + typeName + "\n"
		}
		for _, pair := range outParams {
			result += pair[0] + " " + pair[1] + "\n"
		}
		result += "}\n"
	}

	result += "}\n\n"

	result += formatArgsSame(name, inParams, outParams, subComps)
	result += formatRefreshIfNeeded(name, inParams, outParams, subComps)
	result += formatRefresh(name, inParams, outParams, subComps, usesOn)
	return result
}

func formatArgsSame(name string, inParams [][2]string, outParams [][2]string, subComps []pkgComps) string {
	result := fmt.Sprintf("func (%s %s) areArgsSame(%s) bool{\n", inParams[0][0], inParams[0][1], namesAndTypes(inParams[1:]))
	for idx, pair := range inParams[1:] {
		if strings.HasPrefix(pair[1], ellipsis) {
			// array check
			result += fmt.Sprintf("if len(%s) != len(%s.memoizedParams.%s) {\n return  false\n}\n", pair[0], inParams[0][0], pair[0])
			result += fmt.Sprintf("for %sIndex, %sItem := range %s {\n", pair[0], pair[0], pair[0])
			result += fmt.Sprintf("if %sItem != %s.memoizedParams.%s[%sIndex] {\n return false\n }\n", pair[0], inParams[0][0], pair[0], pair[0])
			result += "}\n"
		} else if idx != len(inParams) - 2 {
			result += fmt.Sprintf("if %s != %s.memoizedParams.%s {\n  return false\n }\n", pair[0], inParams[0][0], pair[0])
		} else {
			return result + fmt.Sprintf("return %s == %s.memoizedParams.%s\n}\n\n", pair[0], inParams[0][0], pair[0])
		}
	}
	return result + "return true\n}\n\n"
}

func formatRefreshIfNeeded(name string, inParams [][2]string, outParams [][2]string, subComps []pkgComps) string {
	result := fmt.Sprintf("func (%s %s) refreshIfNeeded(%s) (%s) {\n", inParams[0][0], inParams[0][1], namesAndTypes(inParams[1:]), namesAndTypes(outParams))

	args := prefixedNames(inParams[1:], "")
	memoizedResults := prefixedNames(outParams, fmt.Sprintf("%s.memoizedParams.", inParams[0][0]))
	if strings.HasPrefix(inParams[len(inParams)-1][1], ellipsis) {
		args += ellipsis
	}

	result += fmt.Sprintf("if !%s.memoInitialized || !%s.areArgsSame(%s) {\n return %s.refresh(%s)\n }\n",
		inParams[0][0], inParams[0][0], args, inParams[0][0], args)
	result += fmt.Sprintf("return " + memoizedResults + "\n}\n\n")

	return result
}

func formatRefresh(name string, inParams [][2]string, outParams [][2]string, subComps []pkgComps, usesOn bool) string {
	result := fmt.Sprintf("func (%s %s) refresh(%s) (%s) {\n", inParams[0][0], inParams[0][1], namesAndTypes(inParams[1:]), namesAndTypes(outParams))

	args := prefixedNames(inParams[1:], "")
	memoizedArgs := prefixedNames(inParams[1:], fmt.Sprintf("%s.memoizedParams.", inParams[0][0]))
	memoizedResults := prefixedNames(outParams, fmt.Sprintf("%s.memoizedParams.", inParams[0][0]))

	result += fmt.Sprintf("%s.memoInitialized = true\n", inParams[0][0])
	if len(inParams) > 1 {
		result += fmt.Sprintf("%s = %s\n", memoizedArgs, args)
	}

	if usesOn {
		result += fmt.Sprintf("%s.Subs.Begin()\ndefer %s.Subs.End()\n", inParams[0][0], inParams[0][0])
	}

	for _, pkgComps := range subComps {
		for _, comp := range pkgComps.comps {
			if pkgComps.pkg != "" {
				comp = pkgComps.pkg + "." + comp
			}
			comp = inParams[0][0] + "." + comp
			result += fmt.Sprintf("%sCache.Begin()\ndefer %sCache.End()\n", comp, comp)
		}
	}

	ell := ""
	if strings.HasPrefix(inParams[len(inParams)-1][1], ellipsis) {
		ell = ellipsis
	}

	result += fmt.Sprintf("%s = %s(%s, %s)\n", memoizedResults, name, inParams[0][0], args+ell)
	result += fmt.Sprintf("return %s\n}\n\n", memoizedResults)

	return result
}

func formatCache(name string, inParams [][2]string, outParams [][2]string, subComps []pkgComps) string {
	resultTypes := ""
	for kk, pair := range outParams {
		if kk > 0 {
			resultTypes += ", "
		}
		resultTypes += pair[1]
	}

	ell := ""
	if strings.HasPrefix(inParams[len(inParams)-1][1], ellipsis) {
		ell = ellipsis
	}

	data := map[string]string{
		"component":    name,
		"cache":        name + "Cache",
		"context":      inParams[0][1][1:],
		"ctx":          inParams[0][0],
		"argsAndTypes": namesAndTypes(inParams[1:]),
		"args":         prefixedNames(inParams[1:], "") + ell,
		"resultTypes":  resultTypes,
	}

	t, err := template.New("cache").Parse(cache)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	if err = t.Execute(&buf, data); err != nil {
		panic(err)
	}
	return buf.String()
}

var cache = `

// {{.cache}} is generated from {{.component}}.  Please see that for 
// documentation
type {{.cache}} struct {
       old, current map[interface{}]*{{.context}}
}

// Begin starts the round
func ({{.ctx}} *{{.cache}}) Begin() {
       {{.ctx}}.old, {{.ctx}}.current = {{.ctx}}.current, map[interface{}]*{{.context}}{}
}

// End ends the round
func ({{.ctx}} *{{.cache}}) End() {
       // TODO: deliver Close() handlers if they exist
       {{.ctx}}.old = nil
}

// {{.component}} implements the cache create or fetch method
func ({{.ctx}} *{{.cache}}) {{.component}}(key interface{}, {{.argsAndTypes}}) ({{.resultTypes}}) {
       {{.ctx}}Old, ok := {{.ctx}}.old[key]

       if ok {
               delete({{.ctx}}.old, key)
       } else {
               {{.ctx}}Old = &{{.context}}{}
       }
       {{.ctx}}.current[key] = {{.ctx}}Old
       return {{.ctx}}Old.refreshIfNeeded({{.args}})
}
`

func namesAndTypes(p [][2]string) string {
	result := ""
	for kk, pair := range p {
		if kk > 0 {
			result += ", "
		}
		result += pair[0] + " " + pair[1]
	}
	return result
}

func prefixedNames(p [][2]string, prefix string) string {
	result := ""
	for kk, pair := range p {
		if kk > 0 {
			result += ", "
		}
		result += prefix + pair[0]
	}
	return result
}

type subVisitor struct {
	ctxtName string
	subs     map[[2]string]bool
	usesOn   bool
}

func (s *subVisitor) Visit(n ast.Node) ast.Visitor {
	if call, ok := n.(*ast.CallExpr); ok {
		if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
			inner := sel.Sel.Name
			s.usesOn = s.usesOn || (inner == "On" && s.isContext(sel.X))
			if inner != "On" && inner != "refresh" {
				if s.isContext(sel.X) {
					s.subs[[2]string{"", inner}] = true
				}
				if sel, ok := sel.X.(*ast.SelectorExpr); ok {
					outer := sel.Sel.Name
					if s.isContext(sel.X) {
						s.subs[[2]string{outer, inner}] = true
					}
				}
			}
		}
	}
	return s
}

func (s *subVisitor) isContext(e ast.Expr) bool {
	if ident, ok := e.(*ast.Ident); ok && ident.Name == s.ctxtName {
		return true
	}
	return false
}
