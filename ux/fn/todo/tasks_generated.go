// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
//
// This code is generated by github.com/dotchain/dot/ux/fn/codegen.go

package todo

import (
	"github.com/dotchain/dot/ux/core"
	"github.com/dotchain/dot/ux/fn"
	"github.com/dotchain/dot/ux/streams"
)

type tasksViewCtx struct {
	streams.Cache
	TaskEditCache
	fn struct {
		fn.ElementCache
	}

	memoInitialized bool
	memoizedParams  struct {
		styles      core.Styles
		showDone    *streams.BoolStream
		showNotDone *streams.BoolStream
		tasks       *TasksStream
		result1     core.Element
	}
}

func (c *tasksViewCtx) areArgsSame(styles core.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) bool {
	if styles != c.memoizedParams.styles {
		return false
	}
	if showDone != c.memoizedParams.showDone {
		return false
	}
	if showNotDone != c.memoizedParams.showNotDone {
		return false
	}
	return tasks == c.memoizedParams.tasks
}

func (c *tasksViewCtx) refreshIfNeeded(styles core.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) (result1 core.Element) {
	if !c.memoInitialized || !c.areArgsSame(styles, showDone, showNotDone, tasks) {
		return c.refresh(styles, showDone, showNotDone, tasks)
	}
	return c.memoizedParams.result1
}

func (c *tasksViewCtx) refresh(styles core.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) (result1 core.Element) {
	c.memoInitialized = true
	c.memoizedParams.styles, c.memoizedParams.showDone, c.memoizedParams.showNotDone, c.memoizedParams.tasks = styles, showDone, showNotDone, tasks
	c.Cache.Begin()
	defer c.Cache.End()
	c.TaskEditCache.Begin()
	defer c.TaskEditCache.End()
	c.fn.ElementCache.Begin()
	defer c.fn.ElementCache.End()
	c.memoizedParams.result1 = TasksView(c, styles, showDone, showNotDone, tasks)
	return c.memoizedParams.result1
}

// TasksViewCache is generated from TasksView.  Please see that for
// documentation
type TasksViewCache struct {
	old, current map[interface{}]*tasksViewCtx
}

// Begin starts the round
func (c *TasksViewCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*tasksViewCtx{}
}

// End ends the round
func (c *TasksViewCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// TasksView implements the cache create or fetch method
func (c *TasksViewCache) TasksView(key interface{}, styles core.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) core.Element {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &tasksViewCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded(styles, showDone, showNotDone, tasks)
}
