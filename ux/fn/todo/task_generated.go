// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
//
// This code is generated by github.com/dotchain/dot/ux/fn/codegen.go

package todo

import (
	"github.com/dotchain/dot/ux/core"
	"github.com/dotchain/dot/ux/fn"
	"github.com/dotchain/dot/ux/streams"
)

type taskEditCtx struct {
	streams.Subs
	newBoolStreamCache
	newTextStreamCache
	fn struct {
		fn.CheckboxCache
		fn.ElementCache
		fn.TextEditCache
	}

	memoInitialized bool
	memoizedParams  struct {
		styles  core.Styles
		task    *TaskStream
		result1 core.Element
	}
}

func (c *taskEditCtx) areArgsSame(styles core.Styles, task *TaskStream) bool {
	if styles != c.memoizedParams.styles {
		return false
	}
	return task == c.memoizedParams.task
}

func (c *taskEditCtx) refreshIfNeeded(styles core.Styles, task *TaskStream) (result1 core.Element) {
	if !c.memoInitialized || !c.areArgsSame(styles, task) {
		return c.refresh(styles, task)
	}
	return c.memoizedParams.result1
}

func (c *taskEditCtx) refresh(styles core.Styles, task *TaskStream) (result1 core.Element) {
	c.memoInitialized = true
	c.memoizedParams.styles, c.memoizedParams.task = styles, task
	c.Subs.Begin()
	defer c.Subs.End()
	c.newBoolStreamCache.Begin()
	defer c.newBoolStreamCache.End()
	c.newTextStreamCache.Begin()
	defer c.newTextStreamCache.End()
	c.fn.CheckboxCache.Begin()
	defer c.fn.CheckboxCache.End()
	c.fn.ElementCache.Begin()
	defer c.fn.ElementCache.End()
	c.fn.TextEditCache.Begin()
	defer c.fn.TextEditCache.End()
	c.memoizedParams.result1 = TaskEdit(c, styles, task)
	return c.memoizedParams.result1
}

// TaskEditCache is generated from TaskEdit.  Please see that for
// documentation
type TaskEditCache struct {
	old, current map[interface{}]*taskEditCtx
}

// Begin starts the round
func (c *TaskEditCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*taskEditCtx{}
}

// End ends the round
func (c *TaskEditCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// TaskEdit implements the cache create or fetch method
func (c *TaskEditCache) TaskEdit(key interface{}, styles core.Styles, task *TaskStream) core.Element {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &taskEditCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded(styles, task)
}

type boolStreamCtx struct {
	memoInitialized bool
	memoizedParams  struct {
		v       bool
		result1 *streams.BoolStream
	}
}

func (c *boolStreamCtx) areArgsSame(v bool) bool {
	return v == c.memoizedParams.v
}

func (c *boolStreamCtx) refreshIfNeeded(v bool) (result1 *streams.BoolStream) {
	if !c.memoInitialized || !c.areArgsSame(v) {
		return c.refresh(v)
	}
	return c.memoizedParams.result1
}

func (c *boolStreamCtx) refresh(v bool) (result1 *streams.BoolStream) {
	c.memoInitialized = true
	c.memoizedParams.v = v
	c.memoizedParams.result1 = newBoolStream(c, v)
	return c.memoizedParams.result1
}

// newBoolStreamCache is generated from newBoolStream.  Please see that for
// documentation
type newBoolStreamCache struct {
	old, current map[interface{}]*boolStreamCtx
}

// Begin starts the round
func (c *newBoolStreamCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*boolStreamCtx{}
}

// End ends the round
func (c *newBoolStreamCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// newBoolStream implements the cache create or fetch method
func (c *newBoolStreamCache) newBoolStream(key interface{}, v bool) *streams.BoolStream {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &boolStreamCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded(v)
}

type textStreamCtx struct {
	memoInitialized bool
	memoizedParams  struct {
		v       string
		result1 *streams.TextStream
	}
}

func (c *textStreamCtx) areArgsSame(v string) bool {
	return v == c.memoizedParams.v
}

func (c *textStreamCtx) refreshIfNeeded(v string) (result1 *streams.TextStream) {
	if !c.memoInitialized || !c.areArgsSame(v) {
		return c.refresh(v)
	}
	return c.memoizedParams.result1
}

func (c *textStreamCtx) refresh(v string) (result1 *streams.TextStream) {
	c.memoInitialized = true
	c.memoizedParams.v = v
	c.memoizedParams.result1 = newTextStream(c, v)
	return c.memoizedParams.result1
}

// newTextStreamCache is generated from newTextStream.  Please see that for
// documentation
type newTextStreamCache struct {
	old, current map[interface{}]*textStreamCtx
}

// Begin starts the round
func (c *newTextStreamCache) Begin() {
	c.old, c.current = c.current, map[interface{}]*textStreamCtx{}
}

// End ends the round
func (c *newTextStreamCache) End() {
	// TODO: deliver Close() handlers if they exist
	c.old = nil
}

// newTextStream implements the cache create or fetch method
func (c *newTextStreamCache) newTextStream(key interface{}, v string) *streams.TextStream {
	cOld, ok := c.old[key]

	if ok {
		delete(c.old, key)
	} else {
		cOld = &textStreamCtx{}
	}
	c.current[key] = cOld
	return cOld.refreshIfNeeded(v)
}
